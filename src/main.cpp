#include <cstdint>
#include <deque>
#include <iomanip>
#include <iostream>
#include <vector>
#include <sstream>

#define NOMINMAX
#include <Windows.h>

bool ReadFile(std::string_view file_path, std::vector<uint8_t>* output_buffer) {
    HANDLE h_input_file = ::CreateFile(
        file_path.data(),      // lpFileName
        GENERIC_READ,          // dwDesiredAccess
        0,                     // dwShareMode
        NULL,                  // lpSecurityAttributes
        OPEN_EXISTING,         // dwCreeationDisposition
        FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
        NULL                   // hTemplateFile
    );

    if (h_input_file == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to open input file: " << GetLastError() << std::endl;
        return false;
    }

    DWORD file_size = ::GetFileSize(h_input_file, nullptr);

    output_buffer->resize(static_cast<size_t>(file_size));

    DWORD number_of_bytes_read;
    BOOL read_success = ::ReadFile(h_input_file, output_buffer->data(), file_size, &number_of_bytes_read, NULL);

    if (!read_success) {
        std::cerr << "Failed to read input file: " << GetLastError() << std::endl;
        CloseHandle(h_input_file);
        return false;
    }

    return true;
}

std::string AppendWildcardToDirectory(std::string path) {
    if (path[path.size() - 1] != '*') {
        if (path[path.size() - 1] != '\\') {
            path.push_back('\\');
        }
        path.push_back('*');
    }

    return path;
}

std::string CodeFriendlyString(std::string str) {
    for (auto& c : str) {
        if (!std::isalnum(c)) {
            c = '_';
        }
    }

    while (!std::isalnum(str.front())) {
        str.erase(0, 1);
    }

    if (std::isdigit(str.front())) {
        str = "_" + str;
    }

    return str;
}

bool WriteFile(std::string_view file_path, std::string_view contents) {
    HANDLE h_output_file = ::CreateFile(
        file_path.data(),      // lpFileName
        GENERIC_WRITE,         // dwDesiredAccess
        0,                     // dwShareMode
        NULL,                  // lpSecurityAttributes
        CREATE_ALWAYS,         // dwCreeationDisposition
        FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
        NULL                   // hTemplateFile
    );

    if (h_output_file == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to create output file: " << GetLastError() << std::endl;
        CloseHandle(h_output_file);
        return false;
    }

    DWORD number_of_bytes_written;

    BOOL write_success = ::WriteFile(
        h_output_file,
        contents.data(),
        (DWORD)contents.size(),
        &number_of_bytes_written,
        NULL
    );

    if (!write_success) {
        std::cerr << "Failed to write output file: " << GetLastError() << std::endl;
        CloseHandle(h_output_file);
        return false;
    }

    return true;
}

int main(int argc, const char* argv[]) {

    if (argc != 3) {
        std::cout << R"(
Usage:

    dir2src <input-path> <output-path>

)";
        return 0;
    }

    std::string input_path  = argv[1];
    std::string output_path = argv[2];

    std::string current_path = input_path;

    std::vector<std::string> open_directory_list{ current_path };

    std::vector<std::string> header_namespaces;

    std::stringstream ss_header_file;
    ss_header_file << R"(// AUTOGENERATED

#pragma once

#include <array>
#include <cstdint>

namespace Bin {
)";

    while (!open_directory_list.empty()) {
        std::string dir = open_directory_list.back();
        open_directory_list.pop_back();

        std::string search_path = AppendWildcardToDirectory(dir);

        WIN32_FIND_DATA find_data = {};
        HANDLE h_find_file = ::FindFirstFile(search_path.c_str(), &find_data);

        while (h_find_file != INVALID_HANDLE_VALUE) {

            if (!strcmp(find_data.cFileName, ".") ||
                !strcmp(find_data.cFileName, "..")) {

BOOL found_next_file = ::FindNextFile(h_find_file, &find_data);
if (!found_next_file) break;
continue;
            }

            std::string relative_path = dir + "\\" + find_data.cFileName;

            if (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                open_directory_list.push_back(relative_path);
            }
            else {
                std::vector<uint8_t> file_data;
                ReadFile(relative_path, &file_data);
                std::cout << relative_path << ": " << file_data.size() << std::endl;

                std::vector<std::string> namespaces;
                std::string s = dir;

                size_t delimiter_idx = 0;
                while (delimiter_idx != std::string::npos) {
                    delimiter_idx = s.find('\\');
                    std::string token = s.substr(0, delimiter_idx);
                    namespaces.push_back(CodeFriendlyString(token));
                    s.erase(0, delimiter_idx + 1);
                }

                std::stringstream ss_cpp_file;
                ss_cpp_file << R"(// AUTOGENERATED

#include <array>
#include <cstdint>

namespace Bin {
)";

                for (const auto& n : namespaces) {
                    ss_cpp_file << "namespace " << n << " {\n";
                }

                ss_cpp_file << "\nstd::array<uint8_t, ";

                std::string array_name = CodeFriendlyString(find_data.cFileName);

                ss_cpp_file << file_data.size() << "> " << array_name << " = {\n\n";

                constexpr size_t split = 12;

                for (size_t i = 0; i < file_data.size(); ++i) {

                    if (i % split == 0) {
                        ss_cpp_file << "    ";
                    }

                    uint8_t c = file_data[i];

                    if (c < 10) ss_cpp_file << "00";
                    else if (c < 100) ss_cpp_file << "0";

                    ss_cpp_file << (int)c;

                    if (i != file_data.size() - 1) {
                        ss_cpp_file << ",";

                        if ((i + 1) % split == 0) {
                            ss_cpp_file << "\n";
                        }
                        else {
                            ss_cpp_file << " ";
                        }
                    }
                }

                ss_cpp_file << "\n\n};\n\n";

                for (auto it = namespaces.rbegin(); it != namespaces.rend(); ++it) {
                    ss_cpp_file << "} // end of namespace " << *it << "\n";
                }
                ss_cpp_file << "} // end of namespace Bin\n";

                std::string output_data = ss_cpp_file.str();

                ::WriteFile(std::string("output\\") + find_data.cFileName + ".cpp", output_data);

                // Populate namespaces for header
                for (size_t i = 0; i < header_namespaces.size(); ++i) {
                    if (header_namespaces[i] != namespaces[i] || namespaces.size() <= i) {
                        size_t diff = header_namespaces.size() - namespaces.size() + 1;

                        for (size_t j = 0; j < diff; ++j) {
                            ss_header_file << "\n}\n";
                        }

                        header_namespaces.resize(i);
                        break;
                    }
                }

                for (size_t i = header_namespaces.size(); i < namespaces.size(); ++i) {
                    header_namespaces.push_back(namespaces[i]);
                    ss_header_file << "\nnamespace " << namespaces[i] << " {\n\n";
                }

                ss_header_file << "extern std::array<uint8_t, " << file_data.size() << "> " << array_name << ";\n";
            }

            BOOL found_next_file = ::FindNextFile(h_find_file, &find_data);
            if (!found_next_file) break;
        }
    }

    for (size_t i = 0; i < header_namespaces.size() + 1; ++i) {
        ss_header_file << "\n}\n";
    }

    std::string header_output_data = ss_header_file.str();
    ::WriteFile("output\\bin.h", header_output_data);

    return 0;
}