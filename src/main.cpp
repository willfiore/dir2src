#include <cstdint>
#include <deque>
#include <iomanip>
#include <iostream>
#include <vector>
#include <sstream>

#define NOMINMAX
#include <Windows.h>

bool ReadFile(std::string_view file_path, std::vector<uint8_t>* output_buffer) {
    HANDLE h_input_file = ::CreateFile(
        file_path.data(),      // lpFileName
        GENERIC_READ,          // dwDesiredAccess
        0,                     // dwShareMode
        NULL,                  // lpSecurityAttributes
        OPEN_EXISTING,         // dwCreeationDisposition
        FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
        NULL                   // hTemplateFile
    );

    if (h_input_file == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to open input file: " << GetLastError() << std::endl;
        return false;
    }

    DWORD file_size = ::GetFileSize(h_input_file, nullptr);

    output_buffer->resize(static_cast<size_t>(file_size));

    DWORD number_of_bytes_read;
    BOOL read_success = ::ReadFile(h_input_file, output_buffer->data(), file_size, &number_of_bytes_read, NULL);

    if (!read_success) {
        std::cerr << "Failed to read input file: " << GetLastError() << std::endl;
        CloseHandle(h_input_file);
        return false;
    }

    return true;
}

std::string CodeFriendlyString(std::string str) {
    for (auto& c : str) {
        if (!std::isalnum(c)) {
            c = '_';
        }
    }

    while (!std::isalnum(str.front())) {
        str.erase(0, 1);
    }

    if (std::isdigit(str.front())) {
        str = "_" + str;
    }

    return str;
}

std::vector<std::string> SplitString(std::string string, const std::string& delimiter) {
    std::vector<std::string> ret;

    size_t delimiter_idx = 0;
    while (delimiter_idx != std::string::npos) {
        delimiter_idx = string.find(delimiter);
        std::string token = string.substr(0, delimiter_idx);

        if (!token.empty()) {
            ret.push_back(token);
        }
        string.erase(0, delimiter_idx + 1);
    }

    return ret;
}

std::string NormalizeDirectoryString(std::string string) {
    if (string.empty()) return string;

    for (auto& c : string) {
        if (c == '/') c = '\\';
    }

    if (string.back() != '\\') {
        string.push_back('\\');
    }

    return string;
}

bool WriteFile(std::string_view file_path, std::string_view contents) {
    HANDLE h_output_file = ::CreateFile(
        file_path.data(),      // lpFileName
        GENERIC_WRITE,         // dwDesiredAccess
        0,                     // dwShareMode
        NULL,                  // lpSecurityAttributes
        CREATE_ALWAYS,         // dwCreeationDisposition
        FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
        NULL                   // hTemplateFile
    );

    if (h_output_file == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to create output file: " << GetLastError() << std::endl;
        CloseHandle(h_output_file);
        return false;
    }

    DWORD number_of_bytes_written;

    BOOL write_success = ::WriteFile(
        h_output_file,
        contents.data(),
        (DWORD)contents.size(),
        &number_of_bytes_written,
        NULL
    );

    if (!write_success) {
        std::cerr << "Failed to write output file: " << GetLastError() << std::endl;
        CloseHandle(h_output_file);
        return false;
    }

    return true;
}

int main(int argc, const char* argv[]) {

    if (argc != 3) {
        std::cout << R"(
Usage:

    dir2src <input-path> <output-path>

)";
        return 0;
    }

    std::string root_input_path  = NormalizeDirectoryString(argv[1]);
    std::string root_output_path = NormalizeDirectoryString(argv[2]);

    std::vector<std::string> root_input_directories = SplitString(root_input_path, "\\");
    std::vector<std::string> root_output_directories = SplitString(root_output_path, "\\");

    std::cout << "Input path:  " << root_input_path << std::endl;
    std::cout << "Output path: " << root_output_path << std::endl;

    std::vector<std::string> open_directory_list{ root_input_path };

    std::vector<std::string> header_namespaces;

    std::stringstream ss_header_file;
    ss_header_file << R"(// AUTOGENERATED

#pragma once

#include <array>
#include <cstdint>

namespace Bin {
)";

    while (!open_directory_list.empty()) {
        std::string dir = NormalizeDirectoryString(open_directory_list.back());
        open_directory_list.pop_back();

        std::string search_path = dir;
        if (search_path.back() != '*') {
            search_path.push_back('*');
        }

        std::cout << "Search path: " << search_path << std::endl;

        WIN32_FIND_DATA find_data = {};
        HANDLE h_find_file = ::FindFirstFile(search_path.c_str(), &find_data);

        while (h_find_file != INVALID_HANDLE_VALUE) {

            if (!strcmp(find_data.cFileName, ".") ||
                !strcmp(find_data.cFileName, "..")) {

                BOOL found_next_file = ::FindNextFile(h_find_file, &find_data);
                if (!found_next_file) break;
                continue;
            }

            std::string relative_path = dir + find_data.cFileName;

            if (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                std::cout << "Added new dir to search list: " << relative_path << std::endl;
                open_directory_list.push_back(relative_path);
            }
            else {
                
                std::vector<uint8_t> file_data;
                ReadFile(relative_path, &file_data);

                std::cout << "Found file: " << find_data.cFileName << ", size: " << file_data.size() << std::endl;

                std::vector<std::string> directories = SplitString(dir, "\\");
                std::vector<std::string> output_directories = directories;
                output_directories.erase(output_directories.begin(), output_directories.begin() + root_input_directories.size());

                std::vector<std::string> namespaces = output_directories;

                output_directories.insert(output_directories.begin(), root_output_directories.begin(), root_output_directories.end());

                for (auto& str : namespaces) {
                    str = CodeFriendlyString(str);
                }

                std::string s = dir;

                std::stringstream ss_cpp_file;
                ss_cpp_file << R"(// AUTOGENERATED

#include <array>
#include <cstdint>

namespace Bin {
)";

                for (const auto& n : namespaces) {
                    ss_cpp_file << "namespace " << n << " {\n";
                }

                ss_cpp_file << "\nstd::array<uint8_t, ";

                std::string array_name = CodeFriendlyString(find_data.cFileName);

                ss_cpp_file << file_data.size() << "> " << array_name << " = {\n\n";

                constexpr size_t split = 12;

                for (size_t i = 0; i < file_data.size(); ++i) {

                    if (i % split == 0) {
                        ss_cpp_file << "    ";
                    }

                    uint8_t c = file_data[i];

                    if (c < 10) ss_cpp_file << "00";
                    else if (c < 100) ss_cpp_file << "0";

                    ss_cpp_file << (int)c;

                    if (i != file_data.size() - 1) {
                        ss_cpp_file << ",";

                        if ((i + 1) % split == 0) {
                            ss_cpp_file << "\n";
                        }
                        else {
                            ss_cpp_file << " ";
                        }
                    }
                }

                ss_cpp_file << "\n\n};\n\n";

                for (auto it = namespaces.rbegin(); it != namespaces.rend(); ++it) {
                    ss_cpp_file << "} // end of namespace " << *it << "\n";
                }
                ss_cpp_file << "} // end of namespace Bin\n";

                std::string output_data = ss_cpp_file.str();

                std::string file_output_path = root_output_path + dir;
                std::vector<std::string> file_output_directory_list = SplitString(file_output_path, "\\");

                // Create nested output directories
                std::string current_directory_path;
                for (const auto& directory : output_directories) {
                    current_directory_path += directory + "\\";
                    ::CreateDirectory(current_directory_path.c_str(), NULL);
                }

                std::cout << "C: " << current_directory_path << std::endl;

                ::WriteFile(current_directory_path + find_data.cFileName + ".cpp", output_data);

                // Populate namespaces for header
                for (size_t i = 0; i < header_namespaces.size(); ++i) {
                    if (header_namespaces[i] != namespaces[i] || namespaces.size() <= i) {
                        size_t diff = header_namespaces.size() - namespaces.size() + 1;

                        for (size_t j = 0; j < diff; ++j) {
                            ss_header_file << "\n}\n";
                        }

                        header_namespaces.resize(i);
                        break;
                    }
                }

                for (size_t i = header_namespaces.size(); i < namespaces.size(); ++i) {
                    header_namespaces.push_back(namespaces[i]);
                    ss_header_file << "\nnamespace " << namespaces[i] << " {\n\n";
                }

                ss_header_file << "extern std::array<uint8_t, " << file_data.size() << "> " << array_name << ";\n";
            }

            BOOL found_next_file = ::FindNextFile(h_find_file, &find_data);
            if (!found_next_file) break;
        }
    }

    for (size_t i = 0; i < header_namespaces.size() + 1; ++i) {
        ss_header_file << "\n}\n";
    }

    std::string header_output_data = ss_header_file.str();
    std::cout << "Outputting header to: " << root_output_path << std::endl;
    ::WriteFile(root_output_path + "bin.h", header_output_data);

    return 0;
}